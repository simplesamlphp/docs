<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Language" content="en">
  <meta name="google-site-verification" content="2S8M18BgYs8cLRL6ClTrfW_xGxfFtMZu2b2jhjrNlss">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SimpleSAMLphp Documentation</title>

  <link rel="stylesheet" href="/res/css/style.css">
  <link rel="stylesheet" href="/res/css/layout.css">
</head>
<body>
<header>
 <div id="header">
  <div class="right">
   <form action="https://www.google.com/cse" method="get" style="margin-top: 2.5rem; margin-right: 2rem">
    <input name="cx" type="hidden" value="004202914224971217557:8ks4jjstupq"/>
    <input name="siteurl" type="hidden" value="www.google.com/cse/home?cx=004202914224971217557:8ks4jjstupq"/>
    <input name="adkw" type="hidden" value="AELymgVJ6Sk-kOvUjbxvgShTLwiFlma2evFuVCh0r8q23vn_4eVnkcdnPfbgMvYUTpJpVlb-KkGAKkbn0i-AlWHsVRR9O0J4CNb6cXFkEKRdjXxsC_NlVD4"/>
    <input name="q" placeholder="Search" type="search" value=""/>
   </form>
  </div>
  <div class="v-center logo-header">
   <div id="logo">
    <a href="https://simplesamlphp.org" style="color: #fff; text-decoration: none">
     <span class="simple">
      Simple
     </span>
     <span class="saml">
      SAML
     </span>
     <span class="simple">
      php
     </span>
    </a>
   </div>
  </div>
 </div>
 <!-- Grey header bar below -->
 <nav>
  <div id="headerbar" style="clear: both">
   <p id="breadcrumb">
    <a href="https://simplesamlphp.org">
     Home
    </a>
    Â» Documentation
   </p>
   <div class="mtoolbar">
    <div class="menuitem">
     <a href="/docs/2.3/index.html">
      2.3 (stable)
     </a>
    </div>
    <div class="menuitem">
     <a href="/docs/2.2/index.html">
      2.2
     </a>
    </div>
    <div class="menuitem">
     <a href="/docs/2.1/index.html">
      2.1
     </a>
    </div>
    <div class="menuitem">
     <a href="/docs/2.0/index.html">
      2.0
     </a>
    </div>
    <div class="menuitem first">
     <a href="/docs/devel/index.html">
      devel
     </a>
    </div>
    <div class="menuitem last">
     <a href="/docs/contributed_modules.html">
      Contributed modules
     </a>
    </div>
   </div>
   <br style="height: 0px; clear: both"/>
  </div>
  <!-- /#headerbar -->
 </nav>
 <div id="content">
 </div>
</header>
<main><h1 id="negotiate-module">
 Negotiate module
</h1>
<p>
 The Negotiate module implements Microsofts Kerberos SPNEGO mechanism.
It is intended to only support Kerberos and not NTLM which RFC4559
implements.
</p>
<dl>
 <dt>
  <code>
   negotiate:Negotiate
  </code>
 </dt>
 <dd>
  Authenticates users via HTTP authentication
 </dd>
</dl>
<h2 id="negotiatenegotiate">
 <code>
  negotiate:Negotiate
 </code>
</h2>
<p>
 Negotiate implements the following mechanics:
</p>
<ul>
 <li>
  Initiate HTTP_AUTHN with the client
 </li>
 <li>
  Authorize user against a LDAP directory
 </li>
 <li>
  Collect metadata from LDAP directory
 </li>
 <li>
  Fall back to other SimpleSamlPhp module for any client/user that
  fails to authenticate in the Negotiate module
 </li>
 <li>
  Check only clients from a certain subnet
 </li>
 <li>
  Supports enabling/disabling a client
 </li>
 <li>
  Supports multiple realm/ldap config for complex AD topology
 </li>
</ul>
<p>
 In effect this module aims to extend the Microsoft AD SSO session to
the SAML IdP. (Or any other Kerberos domain) It doesn't work like this
of course but for the user the client is automatically authenticated
when an SP sends the client to the IdP. In reality Negotiate
authenticates the user via SPNEGO and issues a separate SAML session.
The Kerberos session against the Authentication Server is completely
separate from the SAML session with the IdP. The only time the
Kerberos session affects the SAML session is at authN at the IdP.
</p>
<p>
 The module is meant to supplement existing auth modules and not
replace them. Users do not always log in on the IdP from a machine in
the Windows domain (or another Kerberos domain) and from their own
domain accounts. A fallback mechanism must be supplemented.
</p>
<p>
 The Kerberos TGS can be issued for a wide variety of accounts so an
authoriation backend via LDAP is needed. If the search, with filters,
fails, the fallback in invoked. This to prevent kiosk accounts and the
likes to get faulty SAML sessions.
</p>
<p>
 The subnet is required to prevent excess attempts to authenticate via
Kerberos for clients that always will fail. Worst case scenario the
browser will prompt the user for u/p in a popup box that will always
fail. Only when the user clicks cancel the proper login process will
continue. This is handled through the body of the 401 message the
client receives with the Negotiate request. In the body a URL to the
fallback mechanism is supplied and Javascript is used to redirect the
client.
</p>
<p>
 All configuration is handled in authsources.php:
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">'weblogin' =&gt; [</span>
<span class="x">    'negotiate:Negotiate',</span>
<span class="x">    'keytab' =&gt; '/path/to/keytab-file',</span>
<span class="x">    'realms' =&gt; [</span>
<span class="x">        '*' =&gt; 'ldap',</span>
<span class="x">    ],</span>
<span class="x">    'allowedCertificateHashes' =&gt; [],</span>
<span class="x">    'fallback' =&gt; 'crypto-hash',</span>
<span class="x">    'spn' =&gt; null,</span>
<span class="x">],</span>
<span class="x">'ldap' =&gt; [</span>
<span class="x">    'ldap:LDAP',</span>
<span class="x">    'hostname' =&gt; 'ldap.example.com',</span>
<span class="x">    'enable_tls' =&gt; true,</span>
<span class="x">    'dnpattern' =&gt; 'uid=%username%,cn=people,dc=example,dc=com',</span>
<span class="x">    'search.enable' =&gt; false,</span>
<span class="x">],</span>
<span class="x">'crypto-hash' =&gt; [</span>
<span class="x">    'authcrypt:Hash',</span>
<span class="x">    // hashed version of 'verysecret', made with bin/pwgen.php</span>
<span class="x">    'professor:{SSHA256}P6FDTEEIY2EnER9a6P2GwHhI5JDrwBgjQ913oVQjBngmCtrNBUMowA==' =&gt; [</span>
<span class="x">        'uid' =&gt; ['prof_a'],</span>
<span class="x">        'eduPersonAffiliation' =&gt; ['member', 'employee', 'board'],</span>
<span class="x">    ],</span>
<span class="x">]</span>
</code></pre>
</div>
<h3 id="php_krb5">
 <code>
  php_krb5
 </code>
</h3>
<p>
 The processing involving the actual Kerberos ticket handling is done
by php_krb5.
</p>
<p>
 NOTE! If running using virtual hosts or behind a reverse proxy, you
might need to change the 'spn' variable to 0 (match any entry in the
keytab file) or set it to the specific entry you are trying to match.
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">'spn' =&gt; 'HTTP/host',</span>

<span class="x">'spn' =&gt; 0,</span>
</code></pre>
</div>
<p>
 Depending on you apache config you may need a rewrite rule to allow
php_krb5 to read the HTTP_AUTHORIZATION header:
</p>
<div class="highlight">
 <pre><span></span><code><span class="nb">RewriteEngine</span><span class="w"> </span><span class="k">on</span>
<span class="nb">RewriteCond</span><span class="w"> </span>%{HTTP:Authorization}<span class="w">  </span>!^$
<span class="nb">RewriteRule</span><span class="w"> </span>.*<span class="w"> </span>-<span class="w"> </span>[E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
</code></pre>
</div>
<p>
 Test the Kerberos setup with the following script:
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">if(!extension_loaded('krb5')) {</span>
<span class="x">    die('KRB5 Extension not installed');</span>
<span class="x">}</span>

<span class="x">if (!empty($_SERVER['HTTP_AUTHORIZATION'])) {</span>
<span class="x">    list($mech, $data) = explode(' ', $_SERVER['HTTP_AUTHORIZATION']);</span>
<span class="x">    if (strtolower($mech) == 'basic') {</span>
<span class="x">        echo "Client sent basic";</span>
<span class="x">        die('Unsupported request');</span>
<span class="x">    } else if(strtolower($mech) != 'negotiate') {</span>
<span class="x">        echo "Couldn't find negotiate";</span>
<span class="x">        die('Unsupported request');</span>
<span class="x">    }</span>

<span class="x">    $auth = new KRB5NegotiateAuth('/path/to/keytab');</span>
<span class="x">    $reply = '';</span>
<span class="x">    if ($reply = $auth-&gt;doAuthentication()) {</span>
<span class="x">        header('HTTP/1.1 200 Success');</span>
<span class="x">        echo 'Success - authenticated as ' . $auth-&gt;getAuthenticatedUser() . '&lt;br&gt;';</span>
<span class="x">    } else {</span>
<span class="x">        echo 'Failed to authN.';</span>
<span class="x">        die();</span>
<span class="x">    }</span>
<span class="x">} else {</span>
<span class="x">    header('HTTP/1.1 401 Unauthorized');</span>
<span class="x">    header('WWW-Authenticate: Negotiate',false);</span>
<span class="x">    echo 'Not authenticated. No HTTP_AUTHORIZATION available.';</span>
<span class="x">    echo 'Check headers sent by the browser and verify that ';</span>
<span class="x">    echo 'apache passes them to PHP';</span>
<span class="x">}</span>
</code></pre>
</div>
<h3 id="ldap">
 LDAP
</h3>
<p>
 LDAP is used to verify the user due to the lack of metadata in
Kerberos. A domain can contain lots of kiosk users, non-personal
accounts and the likes. The LDAP lookup will authorize and fetch
attributes as defined by SimpleSAMLphp metadata.
</p>
<p>
 Read the documentation of the LDAP auth module for more information.
</p>
<p>
 This module supports using several Kerberos realms. This requires you to
specify an LDAP configuration for each Kerberos realm that may be used.
If you're using only one realm (one AD domain for example) then you could
let your ldap configuration with the magic "*" key. For multi realms the
syntax is :
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">'weblogin' =&gt; [</span>
<span class="x">    'negotiate:Negotiate',</span>
<span class="x">    ...</span>
<span class="x">    'realms' =&gt; [</span>
<span class="x">        'realm1' =&gt; 'backend for realm1',</span>
<span class="x">        'realm2' =&gt; 'backend for realm2',</span>
<span class="x">        '*' =&gt; 'backend for any other realm',</span>
<span class="x">    ],</span>
<span class="x">],</span>
</code></pre>
</div>
<h3 id="subnet-filtering">
 Subnet filtering
</h3>
<p>
 Subnet is meant to filter which clients you subject to the
WWW-Authenticate request.
</p>
<p>
 Syntax is:
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">'subnet' =&gt; [ '127.0.0.0/16','192.168.0.0/16' ],</span>
</code></pre>
</div>
<p>
 Browsers, especially IE, behave erratically when they encounter a
WWW-Authenticate from the webserver. Included in RFC4559 Negotiate is
NTLM authentication which IE seems prone to fall back to under various
conditions. This triggers a popup login box which defeats the whole
purpose of this module.
</p>
<p>
 TBD: Replace or supplement with LDAP lookups in the domain. Machines
currently in the domain should be the only ones that are prompted with
WWW-Authenticate: Negotiate.
</p>
<h3 id="enablingdisabling-negotiate-from-a-web-browser">
 Enabling/disabling Negotiate from a web browser
</h3>
<p>
 Included in Negotiate are semi-static web pages for enabling and
disabling Negotiate for any given client. The pages simplly set/delete
a cookie that Negotiate will look for when a client attempts AuthN.
The help text in the JSON files should be locally overwritten to fully
explain which clients are accepted by Negotiate.
</p>
<h3 id="channel-binding">
 Channel binding
</h3>
<p>
 A shortage of Kerberos-over-HTTP is that there are no distinguished SPN's for HTTP- and HTTPS-services
 <a href="https://techcommunity.microsoft.com/t5/iis-support-blog/how-to-use-spns-when-you-configure-web-applications-thatare/ba-p/324648">
  1
 </a>
 .
This means that a ticket that's being transmitted over an insecure HTTP-connection can also be used for
HTTPS-connections to the same host. Besides this, Kerberos is also known to be vulnerable for MitM-attacks
where the service-label of the SPN can be altered when an alternative service is available on the same host
 <a href="https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html">
  2
 </a>
 .
</p>
<p>
 To prevent this, certificate-based channel binding is supported by this module as of version v1.1.6.
Syntax for this is:
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">'enforceChannelBinding' =&gt; true,</span>
<span class="x">'allowedCertificateHashes' =&gt; [&lt;SHA-256 finterprint 1&gt;, &lt;SHA-256 fingerprint 2&gt;],</span>
</code></pre>
</div>
<p>
 Usually this array will contain just the one fingerprint for the current HTTPS-certificate of this IdP, but multiple can be
used in a certificate-rollover situation.
If the
 <code>
  enforceChannelBinding
 </code>
 setting is set to
 <code>
  true
 </code>
 , clients that do not provide binding-info will automatically be sent
to the fallback authsource.
</p>
<h3 id="logoutlogin-loop-and-reauthenticating">
 Logout/Login loop and reauthenticating
</h3>
<p>
 Due to the automatic AuthN of certain clients and how SPs will
automatically redirect clients to the IdP when clients try to access
restricted content, a session variable has been put into Negotiate. This
variable makes sure Negotiate doesn't reautenticate a recently logged
out user. The consequence of this is that the user will be presented
with the login mechanism of the fallback module specified in Negotiate
config.
</p>
<p>
 SimpleSamlPHP offers no decent way of adding hooks or piggyback this
information to the fallback module. In future releases one might add a
box of information to the user explaining what's happening.
</p>
<p>
 One can add this bit of code to the template in the fallback AuthN
module:
</p>
<div class="highlight">
 <pre><span></span><code><span class="x">// This should be placed in your www script</span>
<span class="x">$nego_session = false;</span>
<span class="x">$nego_perm = false;</span>
<span class="x">$nego_retry = null;</span>

<span class="x">if (array_key_exists('negotiate:authId', $state)) {</span>
<span class="x">    $nego = \SimpleSAML\Auth\Source::getById($state['negotiate:authId']);</span>
<span class="x">    $mask = $nego-&gt;checkMask();</span>
<span class="x">    $disabled = $nego-&gt;spDisabledInMetadata($spMetadata);</span>
<span class="x">    $session_disabled = $session-&gt;getData('negotiate:disable', 'session');</span>

<span class="x">    if ($mask and !$disabled) {</span>
<span class="x">        if (array_key_exists('NEGOTIATE_AUTOLOGIN_DISABLE_PERMANENT', $_COOKIE) &amp;&amp;</span>
<span class="x">           $_COOKIE['NEGOTIATE_AUTOLOGIN_DISABLE_PERMANENT'] == 'True') {</span>
<span class="x">            $nego_perm = true;</span>
<span class="x">        } elseif ($session_disabled) {</span>
<span class="x">            $retryState = \SimpleSAML\Auth\State::cloneState($state);</span>
<span class="x">            unset($retryState[\SimpleSAML\Auth\State::ID]);</span>
<span class="x">            $nego_retry = \SimpleSAML\Auth\State::saveState($retryState, '\SimpleSAML\Module\negotiate\Auth\Source\Negotiate.StageId');</span>
<span class="x">            $nego_session = true;</span>
<span class="x">        }</span>
<span class="x">    }</span>
<span class="x">}</span>

<span class="x">// This should reside in your template</span>
<span class="x">if ($this-&gt;data['nego']['disable_perm']) {</span>
<span class="x">    echo '&lt;span id="login-extra-info-uio.no" class="login-extra-info"&gt;'</span>
<span class="x">          . '&lt;span class="login-extra-info-divider"&gt;&lt;/span&gt;'</span>
<span class="x">          . $this-&gt;t('{feide:login:login_uio_negotiate_disabled_permanent_info}')</span>
<span class="x">          . '&lt;/span&gt;';</span>
<span class="x">} elseif ($this-&gt;data['nego']['disable_session']) {</span>
<span class="x">     echo '&lt;span id="login-extra-info-uio.no" class="login-extra-info"&gt;'</span>
<span class="x">          . '&lt;span class="login-extra-info-divider"&gt;&lt;/span&gt;'</span>
<span class="x">          . $this-&gt;t('{feide:login:login_uio_negotiate_disabled_session_info}')</span>
<span class="x">          . '&lt;br&gt;&lt;a href="'.SimpleSAML\Module::getModuleURL('negotiate/retry.php', [ 'AuthState' =&gt; $this-&gt;data['nego']['retry_id'] ]).'"&gt;'</span>
<span class="x">          . $this-&gt;t('{feide:login:login_uio_negotiate_disabled_session_info_link}')</span>
<span class="x">          . '&lt;/a&gt;'</span>
<span class="x">          . '&lt;/span&gt;';</span>
<span class="x">}</span>
</code></pre>
</div>
<p>
 The above may or may not work right out of the box for you but it is
the gist of it. By looking at the state variable, cookie and checking
for filters and the likes, only clients that are subjected to
Negotiate should get the help text.
</p>
<p>
 Note that with Negotiate there is also a small script to allow the
user to re-authenticate with Negotiate after being sent to the
fallback mechanism due to the session cookie. In the example above you
can see the construction of the URL. The cloning of the current state
is necessary for retry.php to load a state without triggering a
security check in SSP's state handling library. If you omit this and
pass on the original state you will see a warning in the log like
this:
</p>
<p>
 ```plain text
Sep 27 13:47:36 simplesamlphp WARNING [b99e6131ee] Wrong stage in state. Was 'foo', should be '\SimpleSAML\Module\negotiate\Auth\Source\Negotiate.StageId'.
 <div class="highlight">
  <pre><span></span><code>It will work as loadState will take control and call
Negotiate-&gt;authenticate() but remaining code in retry.php will be
discarded. Other side-effects may occur.

### Clients

#### Internet Explorer

YMMV but generally you need to have your IdP defined in "Internet
Options" -&gt; "Security" -&gt; "Local intranet" -&gt; "Sites" -&gt; "Advanced".
You also need "Internet Options" -&gt; "Advanced" -&gt; "Security" -&gt; Enable
Integrated Windows Authentication" enabled.

#### Firefox

Open "about:config". Locate "network.auth.use-sspi" and verify that
this is true (on a Windows machine). Next locate
"network.negotiate-auth.trusted-uris" and insert your IdP.

#### Safari

TODO

#### Chromium

To allow Kerberos SPN generation on Linux-based platforms, add the
following line to /etc/chromium.d/default-flags:

```bash
export CHROMIUM_FLAGS="$CHROMIUM_FLAGS --auth-server-whitelist=.example.com"
</code></pre>
 </div>
</p>
</main></body>
</html>
